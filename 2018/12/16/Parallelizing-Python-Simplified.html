<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><link rel="shortcut icon" type="image/x-icon" href="/devblog3/favicon.ico"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Parallelizing Python, Simplified | Scott H. Hawley (alt. blog via fastpages)</title>
<meta name="generator" content="Jekyll v3.8.7" />
<meta property="og:title" content="Parallelizing Python, Simplified" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Basic use of multiprocessing." />
<meta property="og:description" content="Basic use of multiprocessing." />
<link rel="canonical" href="https://drscotthawley.github.io/devblog3/2018/12/16/Parallelizing-Python-Simplified.html" />
<meta property="og:url" content="https://drscotthawley.github.io/devblog3/2018/12/16/Parallelizing-Python-Simplified.html" />
<meta property="og:site_name" content="Scott H. Hawley (alt. blog via fastpages)" />
<meta property="og:image" content="https://drscotthawley.github.io/images/parallelpython.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-12-16T00:00:00-06:00" />
<script type="application/ld+json">
{"description":"Basic use of multiprocessing.","url":"https://drscotthawley.github.io/devblog3/2018/12/16/Parallelizing-Python-Simplified.html","@type":"BlogPosting","image":"https://drscotthawley.github.io/images/parallelpython.png","headline":"Parallelizing Python, Simplified","dateModified":"2018-12-16T00:00:00-06:00","datePublished":"2018-12-16T00:00:00-06:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://drscotthawley.github.io/devblog3/2018/12/16/Parallelizing-Python-Simplified.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  <link href="https://unpkg.com/@primer/css/dist/primer.css" rel="stylesheet" />
  <link rel="stylesheet" href="/devblog3/assets/main.css">
  <link rel="stylesheet" href="//use.fontawesome.com/releases/v5.0.7/css/all.css"><link type="application/atom+xml" rel="alternate" href="https://drscotthawley.github.io/devblog3/feed.xml" title="Scott H. Hawley (alt. blog via fastpages)" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
    <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"> </script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"></script>
    <script>
      document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement( document.body, {
          delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "[%", right: "%]", display: true},
            {left: "$", right: "$", display: false}
          ]}
        );
      });
    </script>
  

  <script>
  function wrap_img(fn) {
    if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
        var elements = document.querySelectorAll(".post img");
        Array.prototype.forEach.call(elements, function(el, i) {
            if (el.getAttribute("title")) {
                const caption = document.createElement('figcaption');
                var node = document.createTextNode(el.getAttribute("title"));
                caption.appendChild(node);
                const wrapper = document.createElement('figure');
                wrapper.className = 'image';
                el.parentNode.insertBefore(wrapper, el);
                el.parentNode.removeChild(el);
                wrapper.appendChild(el);
                wrapper.appendChild(caption);
            }
        });
    } else { document.addEventListener('DOMContentLoaded', fn); }
  }
  window.onload = wrap_img;
  </script>

  <script>
    document.addEventListener("DOMContentLoaded", function(){
      // add link icon to anchor tags
      var elem = document.querySelectorAll(".anchor-link")
      elem.forEach(e => (e.innerHTML = '<i class="fas fa-link fa-xs"></i>'));
      // remove paragraph tags in rendered toc (happens from notebooks)
      var toctags = document.querySelectorAll(".toc-entry")
      toctags.forEach(e => (e.firstElementChild.innerText = e.firstElementChild.innerText.replace('¶', '')))
    });
  </script>
</head><body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/devblog3/">Scott H. Hawley (alt. blog via fastpages)</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/devblog3/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Parallelizing Python, Simplified</h1>
    <p class="post-meta"><time class="dt-published" datetime="2018-12-16T00:00:00-06:00" itemprop="datePublished">
        Dec 16, 2018
      </time>•<span class="read-time" title="Estimated read time">
    
    
      9 min read
    
</span></p>
    </header>

  <div class="post-content e-content" itemprop="articleBody">
    <ul class="section-nav">
<li class="toc-entry toc-h2"><a href="#example-1-generate-a-bunch-of-files">Example 1: Generate a bunch of files</a></li>
<li class="toc-entry toc-h2"><a href="#example-2-read-a-bunch-of-files-into-a-list">Example 2: Read a bunch of files into a list</a></li>
<li class="toc-entry toc-h2"><a href="#example-3-filling-a-numpy-array">Example 3: Filling a NumPy array</a></li>
<li class="toc-entry toc-h2"><a href="#ps--final-remarks">P.S.- Final Remarks</a></li>
</ul><p>![](/devblog3/images/parallelpython.png “”)</p>

<p>So you have some serial task that takes forever, and you’re thinking it should be parallelizable, but you find
the documentation on this to be obtuse?  Yea.</p>

<p>Usually I’m interested in either <em>creating</em> lots of data in parallel, or <em>inputting</em> lots of data in parallel, and it’s
often something that I first implemented as a loop but got tired of how slow it runs.  These involve <a href="https://en.wikipedia.org/wiki/Embarrassingly_parallel">embarrassingly parallel</a> tasks in that they don’t depend on one another.</p>

<p>There’s a simple prescription for parallelizing most of these kinds of tasks in Python.  It goes as follows:</p>
<ol>
  <li>Have some kind of task performed in a for loop.</li>
  <li>Write a function that does what you want for one “instance.”  For example, take what’s inside one of your for loops,
put all that in a separate function.</li>
  <li>As a check, keep your loop but use only the function call. Make sure it produces the same results as the original version of your code.</li>
  <li>Use functools.partial to create a wrapper for your function.</li>
  <li>Replace the loop with a call to Pool.map().</li>
</ol>

<p>In the following, we’ll cover 3 examples for parallel tasks:</p>
<ol>
  <li>Generate a bunch of files</li>
  <li>Read a bunch of files into a list</li>
  <li>Filling a numpy array</li>
</ol>

<h2 id="example-1-generate-a-bunch-of-files">
<a class="anchor" href="#example-1-generate-a-bunch-of-files" aria-hidden="true"><span class="octicon octicon-link"></span></a>Example 1: Generate a bunch of files</h2>
<p>Let’s say you have some important synthetic data that you want to generate lots of instances of.
For now, for simplicity, we’re just going to generate images of, let’s say, random noise.  And to make it interesting
we’ll generate 2000 of them.</p>

<p>Here’s the serial for-loop version:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">cv2</span>

<span class="n">n_images</span> <span class="o">=</span> <span class="mi">2000</span>
<span class="n">size_x</span><span class="p">,</span> <span class="n">size_y</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_images</span><span class="p">):</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="mi">255</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">rand</span><span class="p">(</span><span class="n">size_x</span><span class="p">,</span><span class="n">size_y</span><span class="p">)</span>
    <span class="n">filename</span> <span class="o">=</span> <span class="s">'image_'</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="s">'.png'</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"writing file "</span><span class="p">,</span><span class="n">filename</span><span class="p">)</span>
    <span class="n">cv2</span><span class="p">.</span><span class="n">imwrite</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="n">arr</span><span class="p">)</span>
</code></pre></div></div>

<p>Now we write a dedicated function, put it in a <code class="language-plaintext highlighter-rouge">partial</code> wrapper, and call it as follows:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>

<span class="k">def</span> <span class="nf">write_one_file</span><span class="p">(</span><span class="n">size_x</span><span class="p">,</span> <span class="n">size_y</span><span class="p">,</span> <span class="n">name_prefix</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="mi">255</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">rand</span><span class="p">(</span><span class="n">size_x</span><span class="p">,</span><span class="n">size_y</span><span class="p">)</span>
    <span class="n">filename</span> <span class="o">=</span> <span class="n">name_prefix</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="s">'.png'</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"writing file "</span><span class="p">,</span><span class="n">filename</span><span class="p">)</span>
    <span class="n">cv2</span><span class="p">.</span><span class="n">imwrite</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="n">arr</span><span class="p">)</span>

<span class="n">n_images</span> <span class="o">=</span> <span class="mi">2000</span>
<span class="n">size_x</span><span class="p">,</span> <span class="n">size_y</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span>

<span class="n">wrapper</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">write_one_file</span><span class="p">,</span> <span class="n">size_x</span><span class="p">,</span> <span class="n">size_y</span><span class="p">,</span> <span class="s">'image_'</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_images</span><span class="p">):</span>
    <span class="n">wrapper</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</code></pre></div></div>

<p>Finally we replace the loop with a multiprocessing pool. We can either use all the cpus on the machine (which is the default)
or specify how many to use, by giving an argument to <code class="language-plaintext highlighter-rouge">Pool()</code>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span> <span class="k">as</span> <span class="n">mp</span>

<span class="k">def</span> <span class="nf">write_one_file</span><span class="p">(</span><span class="n">size_x</span><span class="p">,</span> <span class="n">size_y</span><span class="p">,</span> <span class="n">name_prefix</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="mi">255</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">rand</span><span class="p">(</span><span class="n">size_x</span><span class="p">,</span><span class="n">size_y</span><span class="p">)</span>
    <span class="n">filename</span> <span class="o">=</span> <span class="n">name_prefix</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="s">'.png'</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"writing file "</span><span class="p">,</span><span class="n">filename</span><span class="p">)</span>
    <span class="n">cv2</span><span class="p">.</span><span class="n">imwrite</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="n">arr</span><span class="p">)</span>

<span class="n">n_images</span> <span class="o">=</span> <span class="mi">2000</span>
<span class="n">size_x</span><span class="p">,</span> <span class="n">size_y</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span>

<span class="n">wrapper</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">write_one_file</span><span class="p">,</span> <span class="n">size_x</span><span class="p">,</span> <span class="n">size_y</span><span class="p">,</span> <span class="s">'image_'</span><span class="p">)</span>

<span class="n">num_procs</span> <span class="o">=</span> <span class="n">mp</span><span class="p">.</span><span class="n">cpu_count</span><span class="p">()</span> <span class="c1"># or can replace with some number of processes to use
</span><span class="n">pool</span> <span class="o">=</span> <span class="n">mp</span><span class="p">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">num_procs</span><span class="p">)</span>
<span class="n">indices</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_images</span><span class="p">)</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">pool</span><span class="p">.</span><span class="nb">map</span><span class="p">(</span><span class="n">wrapper</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
<span class="n">pool</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
<span class="n">pool</span><span class="p">.</span><span class="n">join</span><span class="p">()</span>
</code></pre></div></div>

<p>There are other ways you can do this to get more control, e.g. to have each process in the pool receive a particular
<em>range</em> of indices, but this basic setup will get the job done.  And if you turn off the printing to screen and time the execution,
you’ll see the speedup.</p>

<h2 id="example-2-read-a-bunch-of-files-into-a-list">
<a class="anchor" href="#example-2-read-a-bunch-of-files-into-a-list" aria-hidden="true"><span class="octicon octicon-link"></span></a>Example 2: Read a bunch of files into a list</h2>
<p>This example is actually of limited utility and you may want to just skip down to “Example 3: Filling a numpy array,” but
it’s still an illustrative example that motivates Example 3, and offers a bit of variety in how one might do things.  In this case we’re <em>not</em> going to use Pool.map; instead we’re going to use a context manager for the particular datatype of <code class="language-plaintext highlighter-rouge">list</code>.</p>

<p>Let’s try to load in all the image files we just generated, into a list.  Here’s the serial version:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">cv2</span>

<span class="n">name_prefix</span> <span class="o">=</span> <span class="s">'image_'</span>
<span class="c1"># we'll use glob to get the list of available files
# note that glob order isn't...easily discernible, so we'll sort.
</span><span class="n">img_file_list</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">glob</span><span class="p">.</span><span class="n">glob</span><span class="p">(</span><span class="n">name_prefix</span><span class="o">+</span><span class="s">'*.png'</span><span class="p">))</span>
<span class="n">n_files</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">img_file_list</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">n_files</span><span class="p">,</span><span class="s">"files available."</span><span class="p">)</span>

<span class="n">img_data_list</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_files</span><span class="p">):</span>
    <span class="n">filename</span> <span class="o">=</span> <span class="n">name_prefix</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="s">'.png'</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Reading file"</span><span class="p">,</span><span class="n">filename</span><span class="p">)</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="n">imread</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="n">img_data_list</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">img_data_list</span><span class="p">),</span><span class="s">"images in list."</span><span class="p">)</span>
</code></pre></div></div>

<p>(If we wanted to, we could easily convert this list of images to a numpy array. But let’s hold off on that.)</p>

<p>This time, we’ll split up the tasks manually into equal numbers for each process.
Parallelizing this can take the following form:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Process</span><span class="p">,</span> <span class="n">Manager</span><span class="p">,</span> <span class="n">cpu_count</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">cv2</span>


<span class="k">def</span> <span class="nf">load_one_proc</span><span class="p">(</span><span class="n">img_data_list</span><span class="p">,</span> <span class="n">img_file_list</span><span class="p">,</span> <span class="n">iproc</span><span class="p">,</span> <span class="n">per_proc</span><span class="p">):</span>
    <span class="n">istart</span><span class="p">,</span> <span class="n">iend</span> <span class="o">=</span> <span class="n">iproc</span> <span class="o">*</span> <span class="n">per_proc</span><span class="p">,</span> <span class="p">(</span><span class="n">iproc</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">per_proc</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">istart</span><span class="p">,</span><span class="n">iend</span><span class="p">):</span>    <span class="c1"># each process will read a range of files
</span>        <span class="n">filename</span> <span class="o">=</span> <span class="n">img_file_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Reading file"</span><span class="p">,</span><span class="n">filename</span><span class="p">)</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="n">imread</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="n">img_data_list</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
    <span class="k">return</span>

<span class="n">name_prefix</span> <span class="o">=</span> <span class="s">'image_'</span>
<span class="c1"># we'll use glob to get the list of available files
# note that glob order isn't...easily discernible, so we'll sort.
</span><span class="n">img_file_list</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">glob</span><span class="p">.</span><span class="n">glob</span><span class="p">(</span><span class="n">name_prefix</span><span class="o">+</span><span class="s">'*.png'</span><span class="p">))</span>
<span class="n">n_files</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">img_file_list</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">n_files</span><span class="p">,</span><span class="s">"files available."</span><span class="p">)</span>

<span class="c1"># We'll split up the list manually
</span><span class="n">num_procs</span> <span class="o">=</span> <span class="n">cpu_count</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Parallelizing across"</span><span class="p">,</span><span class="n">num_procs</span><span class="p">,</span><span class="s">"processes."</span><span class="p">)</span>

<span class="n">per_proc</span> <span class="o">=</span> <span class="n">n_files</span> <span class="o">//</span> <span class="n">num_procs</span>  <span class="c1"># Number of files per processor to load
</span><span class="k">assert</span> <span class="n">n_files</span> <span class="o">==</span> <span class="n">per_proc</span> <span class="o">*</span> <span class="n">num_procs</span>  <span class="c1"># Make sure tasks divide evenly. Obvously one can do something more sophisticated than this!
</span>
<span class="k">with</span> <span class="n">Manager</span><span class="p">()</span> <span class="k">as</span> <span class="n">manager</span><span class="p">:</span>
    <span class="n">img_data_list</span> <span class="o">=</span> <span class="n">manager</span><span class="p">.</span><span class="nb">list</span><span class="p">()</span>
    <span class="n">processes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">iproc</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_procs</span><span class="p">):</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">load_one_proc</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">img_data_list</span><span class="p">,</span> <span class="n">img_file_list</span><span class="p">,</span> <span class="n">iproc</span><span class="p">,</span> <span class="n">per_proc</span><span class="p">))</span>
        <span class="n">p</span><span class="p">.</span><span class="n">start</span><span class="p">()</span>
        <span class="n">processes</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">processes</span><span class="p">:</span>
        <span class="n">p</span><span class="p">.</span><span class="n">join</span><span class="p">()</span>
    <span class="n">outside_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">img_data_list</span><span class="p">)</span>   <span class="c1"># Copy out of the Manager context (there may be a better way to do this)
</span>
<span class="k">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">outside_list</span><span class="p">),</span><span class="s">"images in list."</span><span class="p">)</span>
</code></pre></div></div>

<p>Okay, great.  The thing is, that set of processes operates asynchronously, so there’s no telling what <em>order</em> the final list is going to be in.  Maybe you don’t care, but sometimes I care.  One way of dealing with this is to add an index item within the list for each item,
and then sort on that index.</p>

<p>But most of the time what I really want in the end is a numpy array.  So let’s just look at how to fill one of those, directly.</p>

<h2 id="example-3-filling-a-numpy-array">
<a class="anchor" href="#example-3-filling-a-numpy-array" aria-hidden="true"><span class="octicon octicon-link"></span></a>Example 3: Filling a NumPy array</h2>
<p>Data scientist Jonas Teuwen made <a href="https://jonasteuwen.github.io/numpy/python/multiprocessing/2017/01/07/multiprocessing-numpy-array.html">a great post</a> which got me started on how to do this, but then it seems I <a href="https://stackoverflow.com/questions/53757856/segmentation-fault-when-creating-multiprocessing-array">uncovered a bug in numpy’s garbage collection</a> for which there’s <a href="https://github.com/numpy/numpy/pull/12566">now a patch</a>.  Even without the patch, there are a couple workarounds one can use, and I’ll choose
the simpler of the two workarounds.</p>

<p>Let’s load all those images into a numpy array instead of a list. First the serial version:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">cv2</span>

<span class="n">name_prefix</span> <span class="o">=</span> <span class="s">'image_'</span>
<span class="n">img_file_list</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">glob</span><span class="p">.</span><span class="n">glob</span><span class="p">(</span><span class="n">name_prefix</span><span class="o">+</span><span class="s">'*.png'</span><span class="p">))</span>
<span class="n">n_files</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">img_file_list</span><span class="p">)</span>

<span class="n">first_image</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="n">imread</span><span class="p">(</span><span class="n">img_file_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="k">print</span><span class="p">(</span><span class="n">n_files</span><span class="p">,</span><span class="s">"files available.  Shape of first image is"</span><span class="p">,</span><span class="n">first_image</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="s">"Assuming all images are that size."</span><span class="p">)</span>
<span class="n">img_data_arr</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n_files</span><span class="p">]</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span><span class="n">first_image</span><span class="p">.</span><span class="n">shape</span><span class="p">))</span>  <span class="c1"># allocate storage
</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_files</span><span class="p">):</span>
    <span class="n">filename</span> <span class="o">=</span> <span class="n">img_file_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Reading file"</span><span class="p">,</span><span class="n">filename</span><span class="p">)</span>
    <span class="n">img_data_arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="n">imread</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="s">"Finished."</span><span class="p">)</span>
</code></pre></div></div>

<p>For the parallel version, we’re going to have to use a global variable.  Sorry, there’s no away around it, because of Python’s <a href="https://wiki.python.org/moin/GlobalInterpreterLock">Global Interpreter Lock (GIL)</a>.</p>

<p>Without further ado, here’s the parallel, numpy version of the ‘loading a list of images’ shown earlier in Example 2. (One other change: rather than specifying ranges of images for each processor – which I did just for the sake of variety – this time we’ll let Pool.map decide how to – evenly – distribute the tasks.)</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Pool</span><span class="p">,</span> <span class="n">sharedctypes</span><span class="p">,</span> <span class="n">cpu_count</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">import</span> <span class="nn">gc</span>

<span class="n">mp_shared_array</span> <span class="o">=</span> <span class="bp">None</span>                               <span class="c1"># global variable for array
</span><span class="k">def</span> <span class="nf">load_one_proc</span><span class="p">(</span><span class="n">img_file_list</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">mp_shared_array</span>

    <span class="c1"># tmp will end up pointing to the memory address of the shared array we want to populate
</span>    <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">ctypeslib</span><span class="p">.</span><span class="n">as_array</span><span class="p">(</span><span class="n">mp_shared_array</span><span class="p">)</span>

    <span class="n">filename</span> <span class="o">=</span> <span class="n">img_file_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Reading file"</span><span class="p">,</span><span class="n">filename</span><span class="p">)</span>
    <span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="n">imread</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>   <span class="c1"># assign the values into the memory of the shared array
</span>    <span class="k">return</span>

<span class="n">name_prefix</span> <span class="o">=</span> <span class="s">'image_'</span>
<span class="n">img_file_list</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">glob</span><span class="p">.</span><span class="n">glob</span><span class="p">(</span><span class="n">name_prefix</span><span class="o">+</span><span class="s">'*.png'</span><span class="p">))</span>
<span class="n">n_files</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">img_file_list</span><span class="p">)</span>

<span class="n">first_image</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="n">imread</span><span class="p">(</span><span class="n">img_file_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="k">print</span><span class="p">(</span><span class="n">n_files</span><span class="p">,</span><span class="s">"files available.  Shape of first image is"</span><span class="p">,</span><span class="n">first_image</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Assuming all images are that size."</span><span class="p">)</span>
<span class="n">img_data_arr</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n_files</span><span class="p">]</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span><span class="n">first_image</span><span class="p">.</span><span class="n">shape</span><span class="p">))</span>  <span class="c1"># allocate storage
</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">ctypeslib</span><span class="p">.</span><span class="n">as_ctypes</span><span class="p">(</span><span class="n">img_data_arr</span><span class="p">)</span>                  <span class="c1"># tmp variable avoids numpy garbage-collection bug
</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Allocating shared storage for multiprocessing (this can take a while)"</span><span class="p">)</span>
<span class="n">mp_shared_array</span> <span class="o">=</span> <span class="n">sharedctypes</span><span class="p">.</span><span class="n">RawArray</span><span class="p">(</span><span class="n">tmp</span><span class="p">.</span><span class="n">_type_</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)</span>

<span class="n">num_procs</span> <span class="o">=</span> <span class="n">cpu_count</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Parallelizing across"</span><span class="p">,</span><span class="n">num_procs</span><span class="p">,</span><span class="s">"processes."</span><span class="p">)</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">(</span><span class="n">num_procs</span><span class="p">)</span>

<span class="n">wrapper</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">load_one_proc</span><span class="p">,</span> <span class="n">img_file_list</span><span class="p">)</span>
<span class="n">indices</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_files</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="nb">map</span><span class="p">(</span><span class="n">wrapper</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>                <span class="c1"># here's where we farm out the op
</span><span class="n">img_data_arr</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">ctypeslib</span><span class="p">.</span><span class="n">as_array</span><span class="p">(</span><span class="n">mp_shared_array</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">img_data_arr</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># this actually happens pretty fast
</span><span class="n">p</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
<span class="n">p</span><span class="p">.</span><span class="n">join</span><span class="p">()</span>

<span class="c1"># Next couple lines are here just in case you want to move on to other things
#   and force garbage collection
</span><span class="n">mp_shared_array</span> <span class="o">=</span> <span class="bp">None</span>
<span class="n">gc</span><span class="p">.</span><span class="n">collect</span><span class="p">()</span>

<span class="k">print</span><span class="p">(</span><span class="s">"Finished."</span><span class="p">)</span>
</code></pre></div></div>

<p>So that’s the basic implementation.  Let me know in the comments if you have suggestions for improvements, or other ideas!</p>

<h2 id="ps--final-remarks">
<a class="anchor" href="#ps--final-remarks" aria-hidden="true"><span class="octicon octicon-link"></span></a>P.S.- Final Remarks</h2>
<p>Added in a couple thoughts, post-facto:</p>

<p><strong>1. Performance.</strong> Notice that what gets passed to <code class="language-plaintext highlighter-rouge">p.map()</code> is an <em>iterator</em>, which typically you’ll use as either the indices of the members of an array (as we did just now), or it as a range over the number of processors (kinda like we did in Example 2).  In the former case, the system is likely to spawn lots and lots of processes (not all at the same time, but as one ‘job’ finishes the system will spawn a new one, and will keep the “pool” going), which will have a bit of overhead – i.e. latency – each time these start and stop. It’s not much though, and so you probably won’t notice if your goal is merely, “I’m doing this so that I only have to wait 5 minutes instead of an hour to get something done.”  If instead you make the indices in the map over the range of processors on your machine and manually break up
the array indices into chunks (sort of like we did in Example 2), then you won’t be spawning as many processes and so your latency will be considerably lower.  But the gain may be small enough (depending on your system) that you may not notice the difference in performance.  Still, if you want to go all-out for performance, then make the pool.map go over the number of procs you want.  Otherwise, feel free to trust the system to do its thing for you and just use the array (or list) indices for the iterator.</p>

<p><strong>2. When Processes Die.</strong>  Debugging <code class="language-plaintext highlighter-rouge">multiprocessing</code> runs is <em>a pain</em>.  If one process dies (crashes, seg faults, generates any kind of “Error”), it will hang the entire pool and you won’t know why because the error messages won’t come to <code class="language-plaintext highlighter-rouge">stdout</code> or <code class="language-plaintext highlighter-rouge">stderr</code>.  Look elsewhere for tutorials on tools for debugging multiprocessing runs.  Good news is that regular <code class="language-plaintext highlighter-rouge">print</code> statements still come to <code class="language-plaintext highlighter-rouge">stdout</code> for all processes, so one way of debugging is the age-old method of just loading your code with <code class="language-plaintext highlighter-rouge">print</code> statements.</p>

  </div>
  

<style>
#share-buttons {display: inline-block; vertical-align: middle; }
#share-buttons:after {content: ""; display: block; clear: both;}
#share-buttons > div {
    position: relative;
    text-align: left; 
    height: 36px; 
    width: 32px; 
    float: left; 
    text-align: center;
}
#share-buttons > div > svg {height: 16px; fill: #d5d5d5; margin-top: 10px;}
#share-buttons > div:hover {cursor: pointer;}
#share-buttons > div.facebook:hover > svg {fill: #3B5998;}
#share-buttons > div.twitter:hover > svg {fill: #55ACEE;}
#share-buttons > div.linkedin:hover > svg {fill: #0077b5;}
#share-buttons > div.pinterest:hover > svg {fill: #CB2027;}
#share-buttons > div.gplus:hover > svg {fill: #dd4b39;}
#share-buttons > div.mail:hover > svg {fill: #7D7D7D;}
#share-buttons > div.instagram:hover > svg {fill: #C73B92;}
#share-buttons > div.facebook > svg {height: 18px; margin-top: 9px;}
#share-buttons > div.twitter > svg {height: 20px; margin-top: 8px;}
#share-buttons > div.linkedin > svg {height: 19px; margin-top: 7px;}
#share-buttons > div.pinterest > svg {height: 20px; margin-top: 9px;}
#share-buttons > div.gplus > svg {height: 17px; margin-top: 9px; position: relative; left: 1px;}
#share-buttons > div.mail > svg {height: 14px; margin-top: 11px;}
</style>

<span style="color: silver;">Share on: </span><div id="share-buttons">
    <div class="facebook" title="Share this on Facebook" onclick="window.open('http://www.facebook.com/share.php?u=https://drscotthawley.github.io/2018/12/16/Parallelizing-Python-Simplified.html');"><svg viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1343 12v264h-157q-86 0-116 36t-30 108v189h293l-39 296h-254v759h-306v-759h-255v-296h255v-218q0-186 104-288.5t277-102.5q147 0 228 12z"/></svg></div>
    <div class="twitter" title="Share this on Twitter" onclick="window.open('http://twitter.com/home?status=https://drscotthawley.github.io/2018/12/16/Parallelizing-Python-Simplified.html');"><svg viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1684 408q-67 98-162 167 1 14 1 42 0 130-38 259.5t-115.5 248.5-184.5 210.5-258 146-323 54.5q-271 0-496-145 35 4 78 4 225 0 401-138-105-2-188-64.5t-114-159.5q33 5 61 5 43 0 85-11-112-23-185.5-111.5t-73.5-205.5v-4q68 38 146 41-66-44-105-115t-39-154q0-88 44-163 121 149 294.5 238.5t371.5 99.5q-8-38-8-74 0-134 94.5-228.5t228.5-94.5q140 0 236 102 109-21 205-78-37 115-142 178 93-10 186-50z"/></svg></div>
    <div class="linkedin" title="Share this on Linkedin" onclick="window.open('https://www.linkedin.com/shareArticle?mini=true&url=https://drscotthawley.github.io/2018/12/16/Parallelizing-Python-Simplified.html&title=&summary=&source=');"><svg viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M477 625v991h-330v-991h330zm21-306q1 73-50.5 122t-135.5 49h-2q-82 0-132-49t-50-122q0-74 51.5-122.5t134.5-48.5 133 48.5 51 122.5zm1166 729v568h-329v-530q0-105-40.5-164.5t-126.5-59.5q-63 0-105.5 34.5t-63.5 85.5q-11 30-11 81v553h-329q2-399 2-647t-1-296l-1-48h329v144h-2q20-32 41-56t56.5-52 87-43.5 114.5-15.5q171 0 275 113.5t104 332.5z"/></svg></div>
    <div class="pinterest" title="Share this on Pinterest" onclick="window.open('https://pinterest.com/pin/create/button/?url=&media=https://drscotthawley.github.io../images/parallelpython.png&description=');"><svg viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M256 597q0-108 37.5-203.5t103.5-166.5 152-123 185-78 202-26q158 0 294 66.5t221 193.5 85 287q0 96-19 188t-60 177-100 149.5-145 103-189 38.5q-68 0-135-32t-96-88q-10 39-28 112.5t-23.5 95-20.5 71-26 71-32 62.5-46 77.5-62 86.5l-14 5-9-10q-15-157-15-188 0-92 21.5-206.5t66.5-287.5 52-203q-32-65-32-169 0-83 52-156t132-73q61 0 95 40.5t34 102.5q0 66-44 191t-44 187q0 63 45 104.5t109 41.5q55 0 102-25t78.5-68 56-95 38-110.5 20-111 6.5-99.5q0-173-109.5-269.5t-285.5-96.5q-200 0-334 129.5t-134 328.5q0 44 12.5 85t27 65 27 45.5 12.5 30.5q0 28-15 73t-37 45q-2 0-17-3-51-15-90.5-56t-61-94.5-32.5-108-11-106.5z"/></svg></div>
    <div class="gplus" title="Share this on Google Plus" onclick="window.open('https://plus.google.com/share?url=https://drscotthawley.github.io/2018/12/16/Parallelizing-Python-Simplified.html');"><svg viewBox="0 0 2304 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1437 913q0 208-87 370.5t-248 254-369 91.5q-149 0-285-58t-234-156-156-234-58-285 58-285 156-234 234-156 285-58q286 0 491 192l-199 191q-117-113-292-113-123 0-227.5 62t-165.5 168.5-61 232.5 61 232.5 165.5 168.5 227.5 62q83 0 152.5-23t114.5-57.5 78.5-78.5 49-83 21.5-74h-416v-252h692q12 63 12 122zm867-122v210h-209v209h-210v-209h-209v-210h209v-209h210v209h209z"/></svg></div>
    <div class="mail" title="Share this through Email" onclick="window.open('mailto:?&body=https://drscotthawley.github.io/2018/12/16/Parallelizing-Python-Simplified.html');"><svg viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1792 710v794q0 66-47 113t-113 47h-1472q-66 0-113-47t-47-113v-794q44 49 101 87 362 246 497 345 57 42 92.5 65.5t94.5 48 110 24.5h2q51 0 110-24.5t94.5-48 92.5-65.5q170-123 498-345 57-39 100-87zm0-294q0 79-49 151t-122 123q-376 261-468 325-10 7-42.5 30.5t-54 38-52 32.5-57.5 27-50 9h-2q-23 0-50-9t-57.5-27-52-32.5-54-38-42.5-30.5q-91-64-262-182.5t-205-142.5q-62-42-117-115.5t-55-136.5q0-78 41.5-130t118.5-52h1472q65 0 112.5 47t47.5 113z"/></svg></div>
</div><!-- from https://github.com/utterance/utterances -->
<script src="https://utteranc.es/client.js"
        repo="drscotthawley/devblog3"
        issue-term="title"
        label="blogpost-comment"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script><a class="u-url" href="/devblog3/2018/12/16/Parallelizing-Python-Simplified.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/devblog3/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Scott H. Hawley (alt. blog via fastpages)</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Scott H. Hawley (alt. blog via fastpages)</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list">
  <li><a href="https://github.com/drscotthawley"><svg class="social svg-icon"><use xlink:href="/devblog3/assets/minima-social-icons.svg#github"></use></svg> <span class="username">drscotthawley</span></a></li><li><a href="https://www.twitter.com/%40drscotthawley"><svg class="social svg-icon"><use xlink:href="/devblog3/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">@drscotthawley</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>An alternate copy of my development blog, using fastpages. If successful I will replace the main blog with this</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
